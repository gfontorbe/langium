/******************************************************************************
 * This file was generated by langium-cli 0.2.0.
 * DO NOT EDIT MANUALLY!
 ******************************************************************************/

type AbstractElement = {
    cardinality: '*' | '+' | '?'
}


type Condition = {}

type Declaration = {}

type Grammar = {
    definesHiddenTokens: :boolean
    hiddenTokens: Array<Reference<AbstractRule>>
    imports: Array<GrammarImport>
    isDeclared: :boolean
    name: :string
    rules: Array<AbstractRule>
    types: Array<TypeDeclaration>
    usedGrammars: Array<Reference<Grammar>>
}


type GrammarImport = {
    path: :string
}


type NamedArgument = {
    calledByName: :boolean
    parameter?: Reference<Parameter>
    value: Condition
}


type Parameter = {
    name: :string
}


type TypeAttribute = {
    isOptional: :boolean
    name: :string
    type: TypeExpression
}


type TypeExpression = {}

type Action = AbstractElement & {
    feature: :string
    operator: '+=' | '='
    type: :string
}


type Alternatives = AbstractElement & {
    elements: Array<AbstractElement>
}


type Assignment = AbstractElement & {
    feature: :string
    firstSetPredicated: :boolean
    operator: '+=' | '=' | '?='
    predicated: :boolean
    terminal: AbstractElement
}


type CharacterRange = AbstractElement & {
    left: Keyword
    right: Keyword
}


type CrossReference = AbstractElement & {
    deprecatedSyntax: :boolean
    terminal: AbstractElement
    type: Reference<ParserRule>
}


type Group = AbstractElement & {
    elements: Array<AbstractElement>
    firstSetPredicated: :boolean
    guardCondition: Condition
    predicated: :boolean
}


type Keyword = AbstractElement & {
    firstSetPredicated: :boolean
    predicated: :boolean
    value: :string
}


type NegatedToken = AbstractElement & {
    terminal: AbstractElement
}


type RegexToken = AbstractElement & {
    regex: :string
}


type RuleCall = AbstractElement & {
    arguments: Array<NamedArgument>
    firstSetPredicated: :boolean
    predicated: :boolean
    rule: Reference<AbstractRule>
}


type TerminalAlternatives = AbstractElement & {
    elements: Array<AbstractElement>
}


type TerminalGroup = AbstractElement & {
    elements: Array<AbstractElement>
}


type TerminalRuleCall = AbstractElement & {
    rule: Reference<TerminalRule>
}


type UnorderedGroup = AbstractElement & {
    elements: Array<AbstractElement>
}


type UntilToken = AbstractElement & {
    terminal: AbstractElement
}


type Wildcard = AbstractElement & {}

type Conjunction = Condition & {
    left: Condition
    right: Condition
}


type Disjunction = Condition & {
    left: Condition
    right: Condition
}


type LiteralCondition = Condition & {
    true: :boolean
}


type Negation = Condition & {
    value: Condition
}


type ParameterReference = Condition & {
    parameter: Reference<Parameter>
}


type AbstractRule = Declaration & {
    fragment: :boolean
    name: :string
    type: ReturnType
}


type ReturnType = Declaration & {
    name: :string
}


type TypeDeclaration = Declaration & {
    name: :string
    type: TypeExpression
}


type TypeAtom = TypeExpression & {
    builtinType: :string | Keyword
    isArray: :boolean
    isReference: :boolean
    refType: Reference<Declaration>
}


type TypeIntersection = TypeExpression & {
    left: TypeExpression
    right: TypeExpression
}


type TypeSchema = TypeExpression & {
    attributes: Array<TypeAttribute>
}


type TypeUnion = TypeExpression & {
    left: TypeExpression
    right: TypeExpression
}


type ParserRule = AbstractRule & {
    alternatives: AbstractElement
    definesHiddenTokens: :boolean
    entry: :boolean
    hiddenTokens: Array<Reference<AbstractRule>>
    parameters: Array<Parameter>
    wildcard: :boolean
}


type TerminalRule = AbstractRule & {
    hidden: :boolean
    terminal: AbstractElement
}


